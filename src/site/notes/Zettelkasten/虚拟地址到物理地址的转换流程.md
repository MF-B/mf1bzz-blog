---
{"dg-publish":true,"permalink":"/zettelkasten//"}
---

2025-05-04
Status: #idea
Tags: [[Zettelkasten/rCore ch4\|rCore ch4]]

# 虚拟地址到物理地址的转换流程

页式存储将内存分成一小段一小段的,每一个小段叫做一个(虚拟)页面/(物理)页帧
## 应用角度
应用的地址空间被分为一段一段的页面
应用使用的地址算是虚拟地址,这个虚拟地址有两部分组成:VPN+offset
其中$2^{offset}$的大小就是页面的大小.假设offset是12,那么一个页面的大小就是4KB
而虚拟地址我们按48位来算,那么VPN就是48-12=36位.
我们要根据这36位VPN将虚拟地址转化成物理地址.怎么转化呢?
让我们先看物理内存
## 物理角度
物理内存也被分为一段一段的页帧
而且物理地址也是由两部分组成PPN+offset,其中offset和虚拟地址的offset是相同的
如何将虚拟地址转化成物理地址呢?
我们只要将虚拟地址的VPN根据某种映射关系转化成PPN就行了
那么映射关系从哪里来呢？
## 页表
映射关系被维护在一个数据结构中,叫做页表.
它根据输入的VPN,输出一个页表项(PPN+标志位)
页表项结构一般由指令集确定,但大部分都是64位.
也就是一个页表项大小为8B

## 应用虚拟地址转化
那么我们只要给应用分配一个页表就可以实现虚拟地址到物理地址的转化了.
当应用访问000000000(VPN)000(offset)这个虚拟地址时,假设此应用的页表存在映射关系: 
000000000 -> 80000+(标志位), 那么应用实际访问到的地址就是80000(PPN)000(offset)
很好,问题似乎都解决了
但是,考虑一下页表的大小
页表由页表项组成,假设我们将所有的页表项都存储在内存中,并假设VPN为27位,
那么我们一共需要在内存里存储$2^{27}$个页表项,而每个页表项大小为8B,那么整个页表就是1GB
这太大了,相当于一个程序就需要占用1GB的空间.
考虑以下两种解决方法
- 缩小VPN位数
	- 当前VPN位数是27位,加上offset就是39位,39位是512GB,也就是当前应用有512GB的虚拟空间
	- 考虑到现在大部分计算机的内存容量,假设物理内存大小为32GB,我们将512GB缩减到32GB,那VPN需要缩减到23位,页表大小就是64MB.
	- 以我的电脑为例,它运行了约200个进程,那光页表就占用了我12.5GB,而每个应用程序还各自占用了一定内存,当我运行一个大型游戏时,内存就已经不够用了,我们需要寻找另外一种解决办法
- 不存储用不到的页表项
	- 仔细想想,其实我们不需要将页表的每一个页表项都存到内存中,因为应用虚拟空间不一定都在被使用着,我们只需要将应用正在使用的那部分虚拟地址对应的那些页表项存到内存中就行了
显然,第二种方法很好的解决了页表内存占用大的问题
来考虑一下实现
当我们需要转换一个VPN时,此时内存中没有此VPN的页表项,于是操作系统要从加载一个页表项到内存中.由于内存被我们以页帧的形式划分了,所以我们的页表项也要存到页帧的结构中.我们要如何根据VPN找到这个页表项呢?
一个方法是: 操作系统将记录页表项的这个页帧的物理页号记录下来,当需要地址转换时,就根据应用的标记遍历查找这个页帧里对应的页表项.但是由于物理内存的速度很慢,而查找也很耗时,为了系统的性能,我们应该减小进行地址转换的次数以及操作系统遍历页表的速度.
我们首先考虑缩小系统进行地址转换的次数.
一个页表项可以帮助4KB的虚拟地址转换成4KB的物理地址,那么如果一个应用实际用到了4MB的空间,那就需要加载1024个页表项,而一个页帧能存储4KB/8B=512个页表项,也就是说,我们需要加载将1024个页表项一个一个的加载到2个物理页帧中,这相当缓慢,随着应用需要的空间变大,这个速度还会更慢.
既然加载一个都很耗时的话,那我们可以一次性加载很多个页表项到内存中,这就能减少加载页表项到内存的时间了
如果应用需要用到1MB的空间,也就是256个页面,那么它就要依次对0-255号页面添加页表项.那我们为什么不一次性将这256个页表项加载到内存中呢?虽然我们可以简单的将VPN设置为递增顺序,但是我们不知道页表项对应的物理页帧号,应用的VPN号是连续的,但是对应的PPN可能是不连续的,所以我们不能一次性插入多个页表项.如果你想将PPN也设置成连续的,那么内存碎片的问题就又出现了,所以目前我们只能考虑一个一个的将页表项加载进去

让我们先搁置这个问题,考虑优化一下查找速度
在目前的结构下,由于不同应用的页表项被加载到了相同的页帧,那操作系统就需要记录不同应用的页表项在页帧中的位置,当操作系统进行地址转换时,根据不同应用的某种标记来寻找页表项的对应位置,这种方法相当麻烦,而且效率不高,因为它需要遍历来查找标记.
考虑软件工程中的解耦
将不同应用的页表项都加载到一个页帧中使得不同的应用都糅杂到了一起,如果我们将不同应用的页表项分开存储到不同的页帧中,那么我们遍历的时候就不需要遍历其他来自其他应用的页表项了,这就减少了遍历的次数,现在我们只需要遍历来自同一个应用的页表项即可了,而且分开的做法还使得我们不需要给每一个页表项都添加应用的标记了,我们只需要给页帧添加应用的标记即可

现在回过头来思考一下内存浪费的问题,如果应用和页帧绑定到一起的话,那么即便我们只加载1个页表项到这个页帧中,剩下的内存也是会被浪费的,因为这个页帧已经是这个应用专用的了.
那这个内存到底会浪费多少呢?一个页帧大小是4KB,而512个页表项映射到物理页帧就是512个物理页帧,也就是2MB.每个应用浪费的最大空间也就是2MB.
200个应用也就是400MB.这以及比我们之前计算的页表浪费的空间少了很多了.

我们要连续加载的512个页表项对应的虚拟页号来自哪里呢？
来自VPN,毕竟VPN就是虚拟页号
512是$2^9$,那么我们需要取VPN后9位,而VPN一共36位,现在它还剩下27位
如果应用用到的内存超过了512个页表项,那么我们就需要将VPN的前27位+1,
我们就需要将下一个512个页表项加载到另外一个页帧中.
而查找也变简单了,我们只需要根据相位来查找就可以了,虚拟页号的大小对应着页表项的位置,我们不再需要遍历查找
当然,这里加载512个页表项不是说512个页表项都是可用的,对应的映射关系还要一个一个加载

好像又回到最开始的状态了,不过这次的单位是页帧,而不是页表项.
我们能继续套用之前的做法吗?
下面我列举一下前后对比
- 由36位VPN组成的页号 -> 由前27位组成的页号
- 一个36位页号一次性存储512个页表项 -> 一个27位页号一次性存储512页表项
- 页表项存储对应的PPN -> 页表项存储着?
27位的页号对应的页表项存储着什么东西呢?
我们已经能根据512个页号来查找对应的PPN了,那我们就不需要存储PPN了,我们现在不知道的对应关系是27位的页号对应的低9位的页号,所以我们要存储低9位的页号
也就是说,这次页表项中存储着27位页号到9位页号的对应.
我们一次性存储512个页表项,是为了对应页帧大小,这次我们也是一样的,所以我们再存9位,现在还剩下18位VPN,我们继续套用

现在我们得到了分成4个部分的VPN,每个部分都有9位.
当我们想要进行地址转换时,我们需要给页表项存储对应的低9位(0-8)VPN,而想要得到低9位的VPN,我们需要得到9-17位的VPN……最终我们需要得到高9位的VPN,那么高9位的VPN怎么得到呢?由操作系统设置
我们将VPN分为4部分,每一个部分都对应一个页表,我们将高四位叫4级页表,低4位叫1级页表

具体来说,操作系统首先在内存中创建一个存放四级页表的页帧,我们为应用绑定一个四级页表号,然后操作系统根据这个四级页表号查找三级页表号,没有的话就创建一个存放三级页表的页帧,也是一次性存放512个,再根据三级查二级……最后创建对应的一级页表号对应PPN,应用根据这个进行地址转换
当应用用完一级页表对应的512个页表项后,操作系统会创建一个新的1级页表,而2/3/4级页表不会重新创建.

让我们统计一下消耗的内存

最开始,操作系统运行第一个应用程序时,需要创建4/3/2/1级页表,一共占用4个页帧,即16KB,当应用程序用完512个页表项(2MB)后,需要创建一个新的页帧,占用4KB.
假设应用实际用到了S,假设S不是太大,不会导致系统创建新的4级和3级页表,那么他的页表消耗的空间就是$4KB*(S/1G+S/2MB)$由于S/2MB要远大于S/1G,我们将前一项忽略,那一个应用的页表占用的空间就是S/512,这样对于内存占用较小的应用,也就不用担心一个页表占用1G空间的问题了.


___
# References